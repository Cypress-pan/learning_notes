# 1. 两数之和 (Two Sum)

## 题目描述
给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** 的那 **两个** 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。你可以按任意顺序返回答案。

### 示例

**示例 1：**
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

**示例 2：**
输入：nums = [3,2,4], target = 6
输出：[1,2]

**示例 3：**
输入：nums = [3,3], target = 6
输出：[0,1]

## 解题思路
要达到 O(n) 的时间复杂度，核心是 **用空间换时间**（通过消耗额外的内存空间，存储已经计算过的结果或遍历过的元素，避免后续重复计算或遍历），从而避免暴力求解（双层循环）的重复计算。

核心思想：
1. 遍历数组时，用一个哈希表（字典）记录已经遍历过的元素及其下标（字典的 `in` 操作是 O(1)，而列表的 `in` 是 O(n)）。

2. 对于当前遍历的元素 `num`，计算它的补数：`complement = target - num`。

3. 检查补数是否已经存在在哈希表中：  
  - 如果存在，说明之前遍历过的某个元素和当前元素的和等于 `target`，直接返回这两个元素的下标。  
  - 如果不存在，将当前元素 `num` 及其下标存入哈希表，继续遍历下一个元素。
- **时间复杂度**：只遍历一次数组，每个元素的哈希表操作是 O(1)，整体 O(n)。
- **空间复杂度**：最坏情况下需要存储 n-1 个元素到哈希表，空间复杂度 O(n)。

## 代码示例
```python
def twoSum(nums: list[int], target: int) -> list[int]:    
  # 初始化空字典，用于存储已遍历的 元素值：下标    
  num_map = {}    
  for index, num in enumerate(nums):        
    complement = target - num        
    if complement in num_map:            
    # 补数存在，补数下标 + 当前元素下标            
      return [num_map[complement], index]        
    # 不存在，将当前元素和下标存入字典        
    num_map[num] = index    
  return []  # 保证题目有解，此句仅为完整逻辑
