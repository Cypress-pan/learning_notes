# 3. 合并两个有序链表 (Merge Two Sorted Lists)
基于「双指针 + 哑节点」实现的有序链表合并，核心思路为「遍历两个链表，按值大小串联节点」。

## 题目描述
将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

### 示例
输入：list1 = [1,2,4], list2 = [1,3,4]
输出：[1,1,2,3,4,4]

输入：list1 = [], list2 = []
输出：[]

输入：list1 = [], list2 = [0]
输出：[0]

## 解题思路
1. **边界处理**：若其中一个链表为空，直接返回另一个链表；若都为空，返回 None。
2. **哑节点（哨兵节点）**：创建一个虚拟头节点 `dummy`，避免单独处理「头节点为空」的边界情况，用 `cur` 指针遍历并串联结果链表。
3. **双指针遍历**：用 `x_p` 遍历 list1，`y_p` 遍历 list2，比较两个指针指向节点的 `val`：
   - 把值更小的节点接入结果链表，对应指针后移；
   - 结果链表的 `cur` 指针同步后移。
4. **处理剩余节点**：遍历结束后，将未遍历完的链表直接挂接到结果链表尾部（剩余节点已升序）。
5. **返回结果**：返回哑节点的 `next`（即新链表的真实头节点）。

### 运行核心代码
```python

class ListNode(object):
    """链表节点类（力扣环境内置，本地测试需单独定义）"""
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution(object):
    def mergeTwoLists(self, list1, list2):
        """
        :type list1: Optional[ListNode]
        :type list2: Optional[ListNode]
        :rtype: Optional[ListNode]
        解题思路：
        1. 边界处理：空链表直接返回另一个链表；
        2. 哑节点 + 双指针遍历两个有序链表，按值大小串联节点；
        3. 挂接剩余未遍历的节点，返回结果链表头。
        """
        # 边界处理：空链表直接返回另一个（覆盖「两个都空」的场景）
        if not list1:
            return list2
        if not list2:
            return list1
        
        # 哑节点：避免处理头节点为空的情况
        dummy = ListNode(0)
        cur = dummy  # 结果链表的遍历指针
        
        # 双指针遍历两个链表
        x_p = list1
        y_p = list2
        while x_p and y_p:
            # 比较节点值，将更小的节点接入结果链表
            if x_p.val <= y_p.val:
                cur.next = x_p
                x_p = x_p.next
            else:
                cur.next = y_p
                y_p = y_p.next
            cur = cur.next  # 结果指针后移
        
        # 处理剩余节点（简化逻辑：直接挂接剩余链表，无需循环）
        cur.next = x_p if x_p else y_p
        
        # 返回结果链表的真实头节点（哑节点的next）
        return dummy.next
